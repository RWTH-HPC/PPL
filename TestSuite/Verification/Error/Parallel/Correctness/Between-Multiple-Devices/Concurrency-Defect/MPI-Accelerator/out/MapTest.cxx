/*********************************************************************/
/*        This is a generated C++ source file.                       */
/*        Generated by PatternDSL.                                   */
/*********************************************************************/

#include <vector>
#include <cstdint>
#include <string>
#include <limits>
#include <iostream>
#include "includes/Patternlib.hxx"
#include "includes/PThreadsLib.hxx"
#include "includes/MapTest.hxx"
#include "includes/cuda_lib_MapTest.hxx"
#include "mpi.h"
#include "includes/cuda_pool_lib.hxx"
#include "math.h"







/*********************************************************************/
/*        Global Variables                                           */
/*        Generated by PatternDSL .                                  */
/*********************************************************************/



/*********************************************************************/
/*        Function Declarations                                      */
/*        Generated by PatternDSL.                                   */
/*********************************************************************/



int main(int argc, char** argv) {

	int32_t* result_lePGdKBCEb;
	int32_t* result_seq_7VCZEgy7jU;
	int32_t* initial_q9zXNRkOQa;
	int NUM_CORES;
	int NUM_GPUS;

	int rank, nprocs;
	MPI_Status Stat;
	MPI_Init(&argc, &argv);
	MPI_Comm_size(MPI_COMM_WORLD, &nprocs);
	MPI_Comm_rank(MPI_COMM_WORLD, &rank);
	if (rank == 0 ) {
		NUM_CORES = 48;
		NUM_GPUS = 2;
	} else 	if (rank == 1 ) {
		NUM_CORES = 48;
		NUM_GPUS = 2;
	}
	std::vector<Thread> pool(NUM_CORES);
	setPool(&pool);
	std::vector<Thread> gpu_pool(NUM_GPUS);
	setGPUPool(&gpu_pool);
	startExecution();
	startGPUExecution();
	initial_q9zXNRkOQa = Init_List(1, initial_q9zXNRkOQa, 200LL * 1LL);
	result_lePGdKBCEb = Init_List(result_lePGdKBCEb, 200LL * 1LL);
	result_seq_7VCZEgy7jU = Init_List(result_seq_7VCZEgy7jU, 200LL * 1LL);
	if (rank == 0) {
		MPI_Send(&initial_q9zXNRkOQa[100], 100, MPI_INT, 1, 0, MPI_COMM_WORLD);
	} else if (rank == 1) {
		MPI_Recv(&initial_q9zXNRkOQa[100], 100, MPI_INT, 0, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
	}
	int32_t* GPU_Data_tvTuyokNWI;
	if (rank == 0) {
		auto f_alloc_iLmklhyLhQ = [&] () {
			cuda_alloc_wrapper(&GPU_Data_tvTuyokNWI, sizeof(int32_t) * 100);
		};
		getGPUPool()->at(1).addWork(f_alloc_iLmklhyLhQ);
	}
	if (rank == 0) {
		auto f_movement_8rMLD6AEsU = [&] () {
			cuda_host2device_wrapper(&GPU_Data_tvTuyokNWI[0], &initial_q9zXNRkOQa[0], sizeof(int32_t) * 100);
		};
		getGPUPool()->at(1).addWork(f_movement_8rMLD6AEsU);
	}
	int32_t* GPU_Data_UqR4DWHkHZ;
	if (rank == 0) {
		auto f_alloc_p3mdaJ9Idv = [&] () {
			cuda_alloc_wrapper(&GPU_Data_UqR4DWHkHZ, sizeof(int32_t) * 100);
		};
		getGPUPool()->at(1).addWork(f_alloc_p3mdaJ9Idv);
	}
	if (rank == 0) {
		auto f_gpu_a0V8c3egsK = [&] () {
			cuda_wrapper_increment_a0V8c3egsK(GPU_Data_tvTuyokNWI, GPU_Data_UqR4DWHkHZ );
		};
		getGPUPool()->at(1).addWork(f_gpu_a0V8c3egsK);
	}
	int32_t* GPU_Data_1A2p1OS1fD;
	if (rank == 1) {
		auto f_alloc_En08sdqyvv = [&] () {
			cuda_alloc_wrapper(&GPU_Data_1A2p1OS1fD, sizeof(int32_t) * 100);
		};
		getGPUPool()->at(1).addWork(f_alloc_En08sdqyvv);
	}
	if (rank == 1) {
		auto f_movement_hQPLs8RzFm = [&] () {
			cuda_host2device_wrapper(&GPU_Data_1A2p1OS1fD[0], &initial_q9zXNRkOQa[100], sizeof(int32_t) * 100);
		};
		getGPUPool()->at(1).addWork(f_movement_hQPLs8RzFm);
	}
	int32_t* GPU_Data_K1Ga7JASOZ;
	if (rank == 1) {
		auto f_alloc_kz7VKEDnlC = [&] () {
			cuda_alloc_wrapper(&GPU_Data_K1Ga7JASOZ, sizeof(int32_t) * 100);
		};
		getGPUPool()->at(1).addWork(f_alloc_kz7VKEDnlC);
	}
	if (rank == 1) {
		auto f_gpu_NcekzbsFgR = [&] () {
			cuda_wrapper_increment_NcekzbsFgR(GPU_Data_1A2p1OS1fD, GPU_Data_K1Ga7JASOZ );
		};
		getGPUPool()->at(1).addWork(f_gpu_NcekzbsFgR);
	}
	if (rank == 1) {
		auto f_dealloc_09SUczeeEi = [&] () {
			cuda_dealloc_wrapper(GPU_Data_1A2p1OS1fD);
		};
		getGPUPool()->at(1).addWork(f_dealloc_09SUczeeEi);
	}
	if (rank == 0) {
		auto f_movement_hLQ8VF9Xc6 = [&] () {
			cuda_device2host_wrapper(&result_lePGdKBCEb[0], &GPU_Data_UqR4DWHkHZ[0], sizeof(int32_t) * 100);
		};
		getGPUPool()->at(1).addWork(f_movement_hLQ8VF9Xc6);
	}
	if (rank == 0) {
		auto f_dealloc_VOTY9FtnfO = [&] () {
			cuda_dealloc_wrapper(GPU_Data_UqR4DWHkHZ);
		};
		getGPUPool()->at(1).addWork(f_dealloc_VOTY9FtnfO);
	}
	if (rank == 0) {
		auto f_dealloc_o9ZLQvqRTz = [&] () {
			cuda_dealloc_wrapper(GPU_Data_tvTuyokNWI);
		};
		getGPUPool()->at(1).addWork(f_dealloc_o9ZLQvqRTz);
	}
	if (rank == 1) {
		auto f_movement_x15ljGFPBA = [&] () {
			cuda_device2host_wrapper(&result_lePGdKBCEb[100], &GPU_Data_K1Ga7JASOZ[0], sizeof(int32_t) * 100);
		};
		getGPUPool()->at(1).addWork(f_movement_x15ljGFPBA);
	}
	if (rank == 1) {
		auto f_dealloc_K4VFy1k3JC = [&] () {
			cuda_dealloc_wrapper(GPU_Data_K1Ga7JASOZ);
		};
		getGPUPool()->at(1).addWork(f_dealloc_K4VFy1k3JC);
	}
	if (rank == 0) {
		Bit_Mask * mask_ptr_zyjMEp7MgT = new Bit_Mask(2,true);
		mask_ptr_zyjMEp7MgT->setBarrier(1);
		boost::shared_ptr<Bit_Mask>boost_mask_ptr_zyjMEp7MgT (mask_ptr_zyjMEp7MgT);
		cuda_sync_device(boost_mask_ptr_zyjMEp7MgT);
	}
	if (rank == 1) {
		Bit_Mask * mask_ptr_eHL2imZQFO = new Bit_Mask(2,true);
		mask_ptr_eHL2imZQFO->setBarrier(1);
		boost::shared_ptr<Bit_Mask>boost_mask_ptr_eHL2imZQFO (mask_ptr_eHL2imZQFO);
		cuda_sync_device(boost_mask_ptr_eHL2imZQFO);
	}
	if (rank == 1) {
		MPI_Send(&result_lePGdKBCEb[100], 100, MPI_INT, 0, 0, MPI_COMM_WORLD);
	} else if (rank == 0) {
		MPI_Recv(&result_lePGdKBCEb[100], 100, MPI_INT, 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
	}
	if (rank == 0) {
		for ( int32_t i = 0; i < 200; i++ ) {
			result_seq_7VCZEgy7jU[(i)] = initial_q9zXNRkOQa[(i)] + 1;
			if (result_seq_7VCZEgy7jU[(i)] != result_lePGdKBCEb[(i)]) {
				print("value at element ", i, " is wrong!");
				MPI_Abort(MPI_COMM_WORLD, 1);
			}
		}
	}
	finishExecution();
	finishGPUExecution();
	std::free(result_lePGdKBCEb);
	std::free(result_seq_7VCZEgy7jU);
	std::free(initial_q9zXNRkOQa);
	MPI_Finalize();
	return 0;


}

