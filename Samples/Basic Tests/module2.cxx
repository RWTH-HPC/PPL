/*********************************************************************/
/*        This is a generated C++ source file.                       */
/*        Generated by PatternDSL.                                   */
/*********************************************************************/

#include <vector>
#include <cstdint>
#include <string>
#include <limits>
#include <iostream>
#include "includes/Patternlib.hxx"
#include "includes/PThreadsLib.hxx"
#include "includes/module2.hxx"
#include "includes/cuda_lib_module2.hxx"
#include "mpi.h"
#include "includes/cuda_pool_lib.hxx"
#include "math.h"




/*********************************************************************/
/*        Global Variables                                           */
/*        Generated by PatternDSL .                                  */
/*********************************************************************/



/*********************************************************************/
/*        Function Declarations                                      */
/*        Generated by PatternDSL.                                   */
/*********************************************************************/



int main(int argc, char** argv) {

	int32_t* result_EGQknbj5uv;
	int32_t* result_seq_XqRA8FDB1V;
	int32_t* initial_e438q0bUxc;
	int NUM_CORES;
	int NUM_GPUS;

	NUM_CORES = 47;
	NUM_GPUS = 2;
	std::vector<pthread_t> pthreads(0);
	std::vector<Thread*> pool(NUM_CORES);
	setPool(&pool,&pthreads);
	std::vector<ThreadGPU> gpu_pool(NUM_GPUS);
	setGPUPool(&gpu_pool);
	startExecution();
	startGPUExecution();
	initial_e438q0bUxc = Init_List(1, initial_e438q0bUxc, 200LL * 1LL);
	result_EGQknbj5uv = Init_List(result_EGQknbj5uv, 200LL * 1LL);
	result_seq_XqRA8FDB1V = Init_List(result_seq_XqRA8FDB1V, 200LL * 1LL);
	int32_t* GPU_Data_k6xnUuy88m;
	auto f_alloc_8zS0cTtHd0 = [&] () {
		cuda_alloc_wrapper(&GPU_Data_k6xnUuy88m, sizeof(int32_t) * 200);
	};
	getGPUPool()->at(1).addWork(f_alloc_8zS0cTtHd0);
	auto f_movement_131CqDOPeO = [&] () {
		cuda_host2device_wrapper(&GPU_Data_k6xnUuy88m[0], &initial_e438q0bUxc[0], sizeof(int32_t) * 200);
	};
	getGPUPool()->at(1).addWork(f_movement_131CqDOPeO);
	int32_t* GPU_Data_EF5fsd4mcL;
	auto f_alloc_2phLLjHBhm = [&] () {
		cuda_alloc_wrapper(&GPU_Data_EF5fsd4mcL, sizeof(int32_t) * 200);
	};
	getGPUPool()->at(1).addWork(f_alloc_2phLLjHBhm);
	auto f_gpu_gBgKyNg8IY = [&] () {
		cuda_wrapper_increment_gBgKyNg8IY(GPU_Data_k6xnUuy88m, GPU_Data_EF5fsd4mcL );
	};
	getGPUPool()->at(1).addWork(f_gpu_gBgKyNg8IY);
	auto f_dealloc_Haqsd5cTjy = [&] () {
		cuda_dealloc_wrapper(GPU_Data_k6xnUuy88m);
	};
	getGPUPool()->at(1).addWork(f_dealloc_Haqsd5cTjy);
	auto f_movement_iDvpAtZ3Wo = [&] () {
		cuda_device2host_wrapper(&result_EGQknbj5uv[0], &GPU_Data_EF5fsd4mcL[0], sizeof(int32_t) * 200);
	};
	getGPUPool()->at(1).addWork(f_movement_iDvpAtZ3Wo);
	auto f_dealloc_Y5MGkvhOdT = [&] () {
		cuda_dealloc_wrapper(GPU_Data_EF5fsd4mcL);
	};
	getGPUPool()->at(1).addWork(f_dealloc_Y5MGkvhOdT);
	Bit_Mask * mask_ptr_xnLrRW51e9 = new Bit_Mask(2,true);
	mask_ptr_xnLrRW51e9->setBarrier(1);
	boost::shared_ptr<Bit_Mask>boost_mask_ptr_xnLrRW51e9 (mask_ptr_xnLrRW51e9);
	cuda_sync_device(boost_mask_ptr_xnLrRW51e9);
	for ( int32_t i = 0; i < 200; i++ ) {
		result_seq_XqRA8FDB1V[(i)] = initial_e438q0bUxc[(i)] + 1;
		if (result_seq_XqRA8FDB1V[(i)] != result_EGQknbj5uv[(i)]) {
			print("value at element ", i, " is wrong!");
			exit(1);
		}
	}
	finishExecution();
	finishGPUExecution();
	std::free(result_EGQknbj5uv);
	std::free(result_seq_XqRA8FDB1V);
	std::free(initial_e438q0bUxc);
	return 0;


}

