needle {
include "../math"

var Int LIMIT = 0-999
	

var [[Int]] blosum62 = [
[ 4, 0-1, 0-2, 0-2,  0, 0-1, 0-1,  0, 0-2, 0-1, 0-1, 0-1, 0-1, 0-2, 0-1,  1,  0, 0-3, 0-2,  0, 0-2, 0-1,  0, 0-4],
[0-1,  5,  0, 0-2, 0-3,  1,  0, 0-2,  0, 0-3, 0-2,  2, 0-1, 0-3, 0-2, 0-1, 0-1, 0-3, 0-2, 0-3, 0-1,  0, 0-1, 0-4],
[0-2,  0,  6,  1, 0-3,  0,  0,  0,  1, 0-3, 0-3,  0, 0-2, 0-3, 0-2,  1,  0, 0-4, 0-2, 0-3,  3,  0, 0-1, 0-4],
[0-2, 0-2,  1,  6, 0-3,  0,  2, 0-1, 0-1, 0-3, 0-4, 0-1, 0-3, 0-3, 0-1,  0, 0-1, 0-4, 0-3, 0-3,  4,  1, 0-1, 0-4],
[ 0, 0-3, 0-3, 0-3,  9, 0-3, 0-4, 0-3, 0-3, 0-1, 0-1, 0-3, 0-1, 0-2, 0-3, 0-1, 0-1, 0-2, 0-2, 0-1, 0-3, 0-3, 0-2, 0-4],
[0-1,  1,  0,  0, 0-3,  5,  2, 0-2,  0, 0-3, 0-2,  1,  0, 0-3, 0-1,  0, 0-1, 0-2, 0-1, 0-2,  0,  3, 0-1, 0-4],
[0-1,  0,  0,  2, 0-4,  2,  5, 0-2,  0, 0-3, 0-3,  1, 0-2, 0-3, 0-1,  0, 0-1, 0-3, 0-2, 0-2,  1,  4, 0-1, 0-4],
[ 0, 0-2,  0, 0-1, 0-3, 0-2, 0-2,  6, 0-2, 0-4, 0-4, 0-2, 0-3, 0-3, 0-2,  0, 0-2, 0-2, 0-3, 0-3, 0-1, 0-2, 0-1, 0-4],
[0-2,  0,  1, 0-1, 0-3,  0,  0, 0-2,  8, 0-3, 0-3, 0-1, 0-2, 0-1, 0-2, 0-1, 0-2, 0-2,  2, 0-3,  0,  0, 0-1, 0-4],
[0-1, 0-3, 0-3, 0-3, 0-1, 0-3, 0-3, 0-4, 0-3,  4,  2, 0-3,  1,  0, 0-3, 0-2, 0-1, 0-3, 0-1,  3, 0-3, 0-3, 0-1, 0-4],
[0-1, 0-2, 0-3, 0-4, 0-1, 0-2, 0-3, 0-4, 0-3,  2,  4, 0-2,  2,  0, 0-3, 0-2, 0-1, 0-2, 0-1,  1, 0-4, 0-3, 0-1, 0-4],
[0-1,  2,  0, 0-1, 0-3,  1,  1, 0-2, 0-1, 0-3, 0-2,  5, 0-1, 0-3, 0-1,  0, 0-1, 0-3, 0-2, 0-2,  0,  1, 0-1, 0-4],
[0-1, 0-1, 0-2, 0-3, 0-1,  0, 0-2, 0-3, 0-2,  1,  2, 0-1,  5,  0, 0-2, 0-1, 0-1, 0-1, 0-1,  1, 0-3, 0-1, 0-1, 0-4],
[0-2, 0-3, 0-3, 0-3, 0-2, 0-3, 0-3, 0-3, 0-1,  0,  0, 0-3,  0,  6, 0-4, 0-2, 0-2,  1,  3, 0-1, 0-3, 0-3, 0-1, 0-4],
[0-1, 0-2, 0-2, 0-1, 0-3, 0-1, 0-1, 0-2, 0-2, 0-3, 0-3, 0-1, 0-2, 0-4,  7, 0-1, 0-1, 0-4, 0-3, 0-2, 0-2, 0-1, 0-2, 0-4],
[ 1, 0-1,  1,  0, 0-1,  0,  0,  0, 0-1, 0-2, 0-2,  0, 0-1, 0-2, 0-1,  4,  1, 0-3, 0-2, 0-2,  0,  0,  0, 0-4],
[ 0, 0-1,  0, 0-1, 0-1, 0-1, 0-1, 0-2, 0-2, 0-1, 0-1, 0-1, 0-1, 0-2, 0-1,  1,  5, 0-2, 0-2,  0, 0-1, 0-1,  0, 0-4],
[0-3, 0-3, 0-4, 0-4, 0-2, 0-2, 0-3, 0-2, 0-2, 0-3, 0-2, 0-3, 0-1,  1, 0-4, 0-3, 0-2, 11,  2, 0-3, 0-4, 0-3, 0-2, 0-4],
[0-2, 0-2, 0-2, 0-3, 0-2, 0-1, 0-2, 0-3,  2, 0-1, 0-1, 0-2, 0-1,  3, 0-3, 0-2, 0-2,  2,  7, 0-1, 0-3, 0-2, 0-1, 0-4],
[ 0, 0-3, 0-3, 0-3, 0-1, 0-2, 0-2, 0-3, 0-3,  3,  1, 0-2,  1, 0-1, 0-2, 0-2,  0, 0-3, 0-1,  4, 0-3, 0-2, 0-1, 0-4],
[0-2, 0-1,  3,  4, 0-3,  0,  1, 0-1,  0, 0-3, 0-4,  0, 0-3, 0-3, 0-2,  0, 0-1, 0-4, 0-3, 0-3,  4,  1, 0-1, 0-4],
[0-1,  0,  0,  1, 0-3,  3,  4, 0-2,  0, 0-3, 0-3,  1, 0-1, 0-3, 0-1,  0, 0-1, 0-3, 0-2, 0-2,  1,  4, 0-1, 0-4],
[ 0, 0-1, 0-1, 0-1, 0-2, 0-1, 0-1, 0-1, 0-1, 0-1, 0-1, 0-1, 0-1, 0-1, 0-2,  0,  0, 0-2, 0-1, 0-1, 0-1, 0-1, 0-1, 0-4],
[0-4, 0-4, 0-4, 0-4, 0-4, 0-4, 0-4, 0-4, 0-4, 0-4, 0-4, 0-4, 0-4, 0-4, 0-4, 0-4, 0-4, 0-4, 0-4, 0-4, 0-4, 0-4, 0-4,  1]
]

seq maximum_arr([Int] set):Int {
	var Int a = set[0]
	var Int b = set[1]
	var Int c = set[2]
	var Int k
	if a > b{
		k = a
	} else {
		k = b
	}
	if k > c {
		return k
	}
	return c	
}

seq maximum(Int a, Int b, Int c):Int {
	var Int k
	if a > b{
		k = a
	} else {
		k = b
	}
	if k > c {
		return k
	}
	return c	
}

map iteration([[Int]] diagonal):[Int] res {
	res[INDEX] = maximum_arr(diagonal[INDEX])
}

seq main():Int {
	
	var Int max_cols = 4096
	var Int max_rows = 4096
	
	var Int penalty = 10
	
	var [[Int]] InputMatrix = init_List([4096,4096],0)
	var [[Int]] referrence = init_List([4096,4096])
	
	for var Int i = 1 ; i < max_cols; i++{
        for var Int j = 1 ; j < max_rows; j++{
            referrence[i][j] = blosum62[rand()%10 + 1][rand()%10 + 1]
        }
    }
	
	for var Int i = 1; i < max_cols; i++ {
		InputMatrix[i][0] = (0-i)*penalty
	}
	
	for var Int i = 1; i < max_rows; i++ {
		InputMatrix[0][i] = (0-i)*penalty
	}
	
	//var Long time = get_time()
	
	// iterate over each diagonal
	for var Int i = 1; i < max_rows; i++ { //4096
		var Int col = 1
		var Int row = i
		
		// restructure data to use the Map pattern since the dynamic programming pattern is not yet capable
		var [[Int]] diagonal = init_List([4095,3])
		var [Int] diagonal_res = init_List([4095])
		
		for var Int j = 0; j < i; j++ {
			diagonal[col - 1][0] = InputMatrix[row - 1][col - 1] + referrence[row - 1][col - 1]
			diagonal[col - 1][1] = InputMatrix[row - 1][col] - penalty
			diagonal[col - 1][2] = InputMatrix[row][col - 1] - penalty
			col++
			row--
		}
		
		// compute the results of each diagonal in parallel
		diagonal_res = iteration<<<>>>(diagonal)
		
		row = i
		col = 1
		for var Int j = 0; j < i; j++ {
			InputMatrix[row][col] = diagonal_res[col - 1]
			col++
			row--
		}	
	
	}
	
	//time = get_time() - time
	//print("Kernel took:" {time} " us")
	
	// Trace back computation
	var Int j_n = max_cols - 2
	var Int i_n = max_rows - 2
	while i_n>0 && j_n>0 {
        var Int nw
		var Int n
		var Int w
		var Int traceback
        if i_n == max_rows - 2 && j_n == max_cols - 2  {
            write("result.txt", "start:" {InputMatrix[i_n][j_n]})
		}
        if  i_n > 0 && j_n > 0 {
            nw = InputMatrix[i_n-1][j_n - 1]
            w  = InputMatrix[ i_n][j_n - 1 ]
            n  = InputMatrix[(i_n - 1)][j_n]
        }
        else if  i_n == 0 {
            nw = LIMIT
			n = LIMIT
            w  = InputMatrix[ i_n][j_n - 1 ]
        }
        else if  j_n == 0 {
            nw = LIMIT
			w = LIMIT
            n  = InputMatrix[(i_n - 1)][ j_n]
        }

        //traceback = maximum(nw, w, n)
		var Int new_nw = nw + referrence[i_n][j_n]
		var Int new_n = n - penalty
		var Int new_w = w - penalty

        traceback = maximum(new_nw, new_w, new_n)
		
        if traceback == new_nw {
            traceback = nw
		}
        if traceback == new_w {
            traceback = w
		}
        if traceback == new_n {
            traceback = n
		}

        write("result.txt", {traceback})

        if traceback == nw  {
			i_n--
			j_n--
		} else if traceback == w  {
			j_n--
		} else if traceback == n  {
			i_n--
		}
    }

	return 0
}
}
