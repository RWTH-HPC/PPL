package de.parallelpatterndsl;

import de.monticore.literals.*;
import de.monticore.types.*;
import de.monticore.*;

grammar PatternDSL extends de.monticore.literals.Literals,
                        MCBasics
                        {

  symbol scope Module
          = Name "{" Definition* "}";
    /*=================================================================*/
    /*                         Interfaces                             */
    /*=================================================================*/

    interface Expression;

    interface GroundExpression extends Expression;

    interface AssignmentExpressionBase extends Expression;

    interface Type;

    interface Definition;

    interface Statement;

    interface ForControl;

    /**interface InfixExpression = **/
       /** left:GroundExpression operator:"" right:Expression; **/
    /*=================================================================*/
    /*                         Basics                             */
    /*=================================================================*/




    /** <350> **/
    NameExpression implements GroundExpression, AssignmentExpressionBase /** ,Expression**/
        = Name;
    /** <340> **/
    LiteralExpression implements GroundExpression /**, Expression **/
        = Literal;

    Arguments
        =   "(" (Expression || ",")* ")";

    ExtLiteral = Literal;

    /** <380> **/
    /**LitExpression implements GroundExpression, Expression <380> = Literal;**/

    TypeName implements Type <170> = Name;

    ListType implements Type <190> = "[" Type "]";

    /** <190> **/
    ListExpression implements  GroundExpression /**, Expression **/
        = "[" (Expression || ",")* "]";


    /*=================================================================*/
    /*                         DEFINITIONS                             */
    /*=================================================================*/

    Include implements Definition <800>
        = "include" String ;

    symbol Variable implements Definition <800>
        = "var" Type Name ("=" Expression)?;

    symbol Constant implements Definition <800>
        = "const" Name "=" (NameExpression | ListExpression | LiteralExpression);

    FunctionParameters
        = "(" (FunctionParameter || ",")* ")";

    symbol FunctionParameter
        =  Type Name;

    symbol scope Function implements Definition
        = PatternType Name FunctionParameters ":" (Type | FunctionParameter) BlockStatement;

    PatternType
        = Map | Reduction | Serial | Stencil | Recursion | DynamicProgramming;

    Map = "map";

    Reduction = "reduction";

    Serial = "seq";

    Stencil = "stencil";

    Recursion = "recursion";

    DynamicProgramming = "dp";


    /*=================================================================*/
    /*                    CONTROL STATEMENTS                           */
    /*=================================================================*/

    PatternCallStatement implements Statement <500>
            = left:Expression "=" Name "<<<" args:(Expression || ",")* ">>>" Arguments;

    IfStatement implements Statement
        = "if" condition:Expression thenStatement:BlockStatement ("else" elseStatement:ElseStatement )? ;

    ElseStatement
        = BlockStatement | IfStatement;

    ReturnStatement implements Statement
        = "return" returnExpression:Expression?;

    scope ForStatement implements Statement
        = "for" ForControl BlockStatement;


    CommonForControl implements ForControl
        = ForInit ";" condition:Expression ";" Expression;

    ForEachControl implements ForControl
        = Variable "in" Expression;

    ForInit
        = Expression | Variable;

    LoopSkipStatement implements Statement
        = BreakStatement | ContinueStatement;

    BreakStatement
        = "break";

    ContinueStatement
        = "continue";

    WhileStatement implements Statement
        = "while" condition:Expression BlockStatement;

    scope BlockStatement implements Statement
        = "{" BlockElement* "}";

    BlockElement
        = (Statement | Variable | Expression | Constant);




    /*=================================================================*/
    /*                         Utility Expressions                       */
    /*=================================================================*/

     CallExpression implements  GroundExpression <50>
     = call:GroundExpression Arguments;

     astrule CallExpression = Name;

     /** <114> **/
     ConditionalExpression implements Expression <114>
     = condition:GroundExpression "?" trueExpression:Expression ":" falseExpression:Expression;
     /** <290> **/
     FieldAccessExpression implements Expression <290> =
         Expression "." Name;

    /** <310> **/
    BracketExpression implements GroundExpression <70> /**, Expression <310> **/
        =  "(" Expression ")";

    /** <180> **/
    /** , GroundExpression, AssignmentExpressionBase weg dann geht**/
    IndexAccessExpression implements GroundExpression<10>, AssignmentExpressionBase<10> /**, Expression <10> **/
        = indexAccess:GroundExpression "[" index:Expression "]" ; /**(Expression)?**/

    InExpression implements Expression
        = left:GroundExpression "in" right:Expression;
    /*=================================================================*/
    /*                    OPERATOR EXPRESSIONS                         */
    /*=================================================================*/


    ReadExpression implements GroundExpression /**, Expression **/
        = "read" "(" StringLiteral ")";

    PrintExpression implements GroundExpression /**, Expression **/
        = "print" "(" PrintElement* ")";

    WriteExpression implements GroundExpression /**, Expression **/
        = "write" "(" StringLiteral "," PrintElement* ")";

    PrintElement = StringLiteral | "{" Expression "}";
    /** <210> **/
    PlusPrefixExpression implements GroundExpression <210> /**, Expression <210> **/
    = "+" Expression;
    /** <210> **/
    MinusPrefixExpression implements GroundExpression<210> /**, Expression <210> **/
    = "-" Expression;
    /** <200> **/
    BooleanNotExpression implements GroundExpression <200> /**, Expression <200> **/
    = "~"  Expression;
    /** <190> **/
    LogicalNotExpression implements GroundExpression<190> /**, Expression <190> **/
    = "!" Expression;
    /** <180> **/
    MultExpression implements Expression <180> /**, InfixExpression **/=
        left:GroundExpression operator:"*" right:Expression;
    /** <180> **/
    DivideExpression implements Expression <180> /**, InfixExpression **/=
        left:GroundExpression operator:"/" right:Expression;
    /** <180> **/
    ModuloExpression implements Expression <180> /**, InfixExpression **/=
        left:GroundExpression operator:"%" right:Expression;
    /** <170> **/
    PlusExpression implements Expression <170> /**, InfixExpression **/=
        left:GroundExpression operator:"+" right:Expression;
    /** <170> **/
    MinusExpression implements Expression <170> /**, InfixExpression **/=
        left:GroundExpression operator:"-" right:Expression;

    /** <120> **/
    BooleanAndOpExpressionDiff implements Expression <120> /**, InfixExpression**/
        = left:GroundExpression operator:"and" right:Expression;
    /** <117> **/
    BooleanOrOpExpressionDiff implements Expression <117> /**, InfixExpression**/
        = left:GroundExpression operator:"or" right:Expression;

    BooleanNotOpExpressionDiff implements GroundExpression<200>
        = "not" Expression;
    /** <120> **/
    RemainderExpressionDiff implements Expression <120> /**, InfixExpression**/
        = left:GroundExpression operator:"mod" right:Expression;

    BitwiseNotExpression implements GroundExpression, Expression
        = "~" Expression;

    BitwiseOrExpression implements Expression
        = left:GroundExpression operator:"|" right:Expression;

    BitwiseAndExpression implements Expression
        = left:GroundExpression operator:"&" right:Expression;

    LengthExpression implements GroundExpression<20> /**, Expression<20> **/
        = "#" Expression;


    /** <250> **/
    IncrementExpression implements  Expression <250>
        = left:Expression "++";

    DecrementExpression implements  Expression
        = left:Expression "--";

    /*=================================================================*/
    /*                    comparison EXPRESSIONS                       */
    /*=================================================================*/
    LessEqualExpression implements Expression /**, InfixExpression **/=
        left:GroundExpression operator:"<=" right:Expression;
    /** <150> **/
    GreaterEqualExpression implements Expression <150> /**, InfixExpression **/=
        left:GroundExpression operator:">=" right:Expression;
    /** <150> **/
    LessThanExpression implements Expression <150> /**, InfixExpression**/ =
        left:GroundExpression operator:"<" right:Expression;
    /** <150> **/
    GreaterThanExpression implements Expression <150> /**, InfixExpression**/ =
        left:GroundExpression operator:">" right:Expression;
    /** <130> **/
    EqualsExpression implements Expression <130> /**, InfixExpression **/=
        left:GroundExpression operator:"==" right:Expression;
    /** <130> **/
    NotEqualsExpression implements Expression <130> /**, InfixExpression **/=
        left:GroundExpression operator:"!=" right:Expression;
    /** <120> **/
    BooleanAndOpExpression implements Expression <120> /**, InfixExpression **/=
        left:GroundExpression operator:"&&" right:Expression;
    /** <117> **/
    BooleanOrOpExpression implements Expression <117> /**, InfixExpression **/=
        left:GroundExpression operator:"||" right:Expression;

    /*=================================================================*/
    /*                    Assignment EXPRESSIONS                         */
    /*=================================================================*/

    /** <20> **/
    AssignmentExpression implements Expression <20>
        = left:AssignmentExpressionBase "=" right:Expression;

    AssignmentByIncreaseExpression implements Expression <20>
        = left:AssignmentExpressionBase "+=" right:Expression;

    AssignmentByDecreaseExpression implements Expression <20>
        = left:AssignmentExpressionBase "-=" right:Expression;

    AssignmentByMultiplyExpression implements Expression <20>
        = left:AssignmentExpressionBase "*=" right:Expression;

    AssignmentByBitwiseAndExpression implements Expression <20>
        = left:AssignmentExpressionBase "&=" right:Expression;

    AssignmentByBitwiseOrExpression implements Expression <20>
        = left:AssignmentExpressionBase "|=" right:Expression;

}
